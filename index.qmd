---
title: "DimensionalData.jl"
subtitle: ""
author:
  - name: Rafael Schouten
    orcid: 
    email: rafaelschouten@gmail.com
    affiliation: 
      - name: Globe Intstitute, Copenhagen University
      - department: Section for Biodiversity
date: "2024-07-10"
# bibliography: AutoDiff.bib
engine: julia
format:
  revealjs:
    incremental: true
    toc: false
    toc-depth: 1
    toc-incremental: false
    slide-number: true
    overview: true
    code-line-numbers: false
    theme: [dark, style.scss]
execute:
    echo: true
---

# Why anyother named array package?

- Geospatial raster data are essentially 2-N dimensional arrays
- They usually have named dimensions and lookup values 
- There are a _lot_ of lookup configurations possible in the wild
- Multi-array datasets that share some or all dimensions are very common
- Other data follows similar patterns, so make it generic

# Why not use existing package?

- Other options were not extensible enough
- I had to change too many things to get through PR reviews
- The lisp curse

## Dimensions

Wrappers types mark an object belongs to a dimension:
\
```{julia}
using DimensionalData 
X(1)
```
\
```{julia}
X(50:10:100)
```
\
```{julia}
X(Not(At(70)))
```

---

Or can be used in `dims` keywords:
```julia
mapslices(sum, A; dims=X)
```

But Symbols work too there:

```julia
mapslices(sum, A; dims=:X)
```

--- 

"Standard" dimensions (90% of spatial data):

```{julia}
X, Y, Z, Ti
```

Arbitrary dimensions (everything else)

```{julia}
Dim{:name}
```

## Lookups

- `Lookup <: AbstractArray` arrays that hold another AbstractArray with lookup metadata.
  - points or intervals
  - sampled or categorical. 
  - `Lookup`s are extensible, Rasters.jl lookups have a coordinate reference system
- These properties change how selectors work for both correctness and performance
- Mostly, lookups are generated automatically by any `AbstractDimArray` constructor,
  - you can ignore them until you need something specific.

# Array Constructors

1 dimensional with a categorical X dimension

```{julia}
using DimensionalData, CairoMakie
A = DimArray([1, 2, 3], X([:a, :b, :c]))
Makie.plot(A)
```

---

Or 2 dimensional with arbitrary dim names:

```{julia}
using DimensionalData, CairoMakie
A = DimArray(rand(3, 4), (a=[:a, :b, :c], b=10.0:10:40.0))
Makie.plot(A)
```

---

Direct constructors

```{julia}
Makie.plot(rand(X(20:2:50), Y(4)))
```

`fill`, `zeros`, `ones` work the same way. 

# Named indexing

No-cost abstractions

```{julia}
using DimensionalData, BenchmarkTools
A = rand(X(10), Y(5))

@btime $A[7, 4]        # Base syntax
@btime $A[Y(4), X(7)]  # Dimension wrappers
@btime $A[Y=4, X=7]    # Keyword syntax
```

# Selectors

## Fast lookups
\
```{julia}
using DimensionalData, BenchmarkTools, Dates
using DimensionalData.Lookups
A = DimArray([1, 2, 3, 4], (X([10.0, 20.0, 40.0, 80.0])))
A[X(At(80.0))]
A[X(Near(85))]
```


## Lookups over Intervals
\
```{julia}
A = DimArray(100:100:9900, X(1.0:1.0:99.0; sampling=Intervals(Start())))
bounds(A, X)
A[X(Contains(9.5))]
```

## Base methods: `dims` keywords
\
```{julia}
A = rand(X(20:10:40), Y([:a, :b, :c]))
reverse(A; dims=Y)
```

# DimensionalData methods

- `broadcast_dims`: dimensionally aware broadcasts - `@d` coming soon!
- `groupby`: dimensional groupby: group data by lookup values

# Plotting

## Plots.jl

```{julia}
using Plots
Plots.scatter(rand(X([:a, :b, :c, :d])))
```

## Makie.jl

```{julia}
using CairoMakie, Distributions
Makie.heatmap(rand(Normal(), X(100:10:200), Y([:a, :b, :c])))
```

# Integrations

- [Rasters]()
- [YAXArrays]() 
- [ClimateBase]()
- [AstroImages]()
- [Arviz]()
- [DynamicGrids]()

# Docs

[Docs](https://rafaqz.github.io/DimensionalData.jl/v0.27.3/)
