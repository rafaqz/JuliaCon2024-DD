---
title: "DimensionalData.jl"
subtitle: ""
author:
  - name: Rafael Schouten
    orcid: 
    email: rafaelschouten@gmail.com
    affiliation: 
      - name: Globe Intstitute, Copenhagen University
      - department: Section for Biodiversity
date: "2024-07-10"
# bibliography: AutoDiff.bib
engine: julia
format:
  revealjs:
    incremental: false
    toc: false
    toc-depth: 1
    toc-incremental: false
    slide-number: true
    overview: true
    code-line-numbers: false
    theme: [dark, style.scss]
execute:
    echo: true
---

## Why another named array package?

::: {.incremental}
- Geospatial data have 
  - named dimensions and lookup values 
  - a _lot_ of lookup configurations no package could describe
  - multi-array datasets
- ![xarray](https://xarray.dev/xarray-datastructure.png)
:::

# Dimensions

## Dimension can hold anything
\
They mark that the wrapped object belongs to the dimension:
```{julia}
using DimensionalData 
X(1)
```
```{julia}
X(50:10:100)
```
```{julia}
X(Not(At(70)))
```

--- 
\
\
\
"Standard" dimensions (90% of spatial data):

```{julia}
X, Y, Z, Ti
```
\
Arbitrary dimensions (everything else)

```{julia}
Dim{:name}
```

# Lookups

`AbstracArray`s that hold another `AbstractArray` and lookup traits

- `Sampled` and `Categorical` are the most common
- mostly detected automatically in array constructors
- traits assists both performance and correctness

# Array Constructors

```{julia}
#| echo: false
global A
global S
```

## 1 dimensional

With a categorical X dimension
\

```{julia}
A = DimArray([1, 2, 3], X([:a, :b, :c]))
```

## N dimensional 

With arbitrary `Dim` dimensions:

```{julia}
A = DimArray(rand(3, 4), (a=[:a, :b, :c], b=10.0:10:40.0))
```

With standard dimensions:

```{julia}
A = DimArray(rand(3, 4), (X([:a, :b, :c]), Y(10.0:10:40.0)))
```

# Stack Constructor

```{julia}
S = DimStack(
  (layer1=rand(Float32, 3, 4), layer2=zeros(Bool, 3, 4)), 
  (X([:a, :b, :c]), Ti(10.0:10:40.0))
)
```

# Named indexing

DimArray:
```{julia}
using BenchmarkTools
@btime $A[3, 4]        # Base Julia syntax
@btime $A[Y(4), X(3)]  # Dimension wrappers
@btime $A[Y=4, X=3]    # Keyword syntax
```

DimStack:
```{julia}
@btime $S[Ti(4), X(3)] # Dimension wrappers
@btime $S[Ti=4, X=3]   # Keyword syntax
```

# Selectors

## At
\
Find exact or approximate matches
\
```{julia}
A = DimArray([1, 2, 3, 4], (X([10.0, 20.0, 40.0, 80.0])))
A[X(At(80.0))]
```

```{julia}
A[X(At(80.09; atol=0.1))]
```

## Near
\
Find the closest match
\
```{julia}
A[X(Near(85))]
```

## Contains
\
Find the interval that contains a value
\
```{julia}
# Define a DimArray with Intervals lookup
using DimensionalData.Lookups
A = DimArray(100:100:9900, X(1.0:1.0:99.0; sampling=Intervals(Start())))
# Index with Contains
A[X(Contains(9.5))]
```

## .. (an IntervalSets.jl Interval)
\
Select data inside an interval
\
```{julia}
A[X=9.5 .. 15]
```

## Where
\
Make dimensional queries
\
```{julia}
A[X=Where(isodd)]
```

# Plotting

## Plots.jl

```{julia}
using Plots
Plots.scatter(rand(X([:a, :b, :c, :d])))
```

## Makie.jl

```{julia}
using CairoMakie, Distributions
Makie.heatmap(rand(Normal(), X(100:10:200), Y([:a, :b, :c])))
```

# Integrations

- [Rasters.jl]()
- [YAXArrays.jl]() 
- [ClimateBase.jl]()
- [AstroImages.jl]()
- [Arviz.jl]()
- [DynamicGrids.jl]()
- [PyramidScheme.jl]()

# New Docs

(Thanks Lazaro Alonzo!)

[Docs](https://rafaqz.github.io/DimensionalData.jl/v0.27.3/)
